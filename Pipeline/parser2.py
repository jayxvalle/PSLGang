"""
Parser for .mzML files to extract spectra with ms level = 1

This script extracts information from .mzML files generated by mass spectrometers.
It searches for spectra with ms level = 1, and for each such spectrum, it collects:
- Spectrum ID
- MS level metadata
- Base peak m/z 
- Base peak intensity

The extracted data is saved as a JSON file in the same directory as the input .mzMl file

Usage: 
    python Parser.py [path_to_mzML_file] (work in progrss)

If no file is specified, the script looks for a default .mzML file in the Data/ folder

Dependencies:
- Python 3.x
- Standard libraries: re, xml.etree.ElementTree, json, os, sys

Typical Output: <input_filename>.mslevel1.json
"""


import re
import xml.etree.ElementTree as ET
import json
import os
import sys
from decimal import Decimal

# -------------------------------------------------------------------
# File Path Setup
# -------------------------------------------------------------------
# The script supports two ways to locate the .mzML input file:
#   1. Command-line argument: python Parser.py /path/to/file.mzML
#   2. Default search: automatically checks known locations under Data/ or data/
#
# Example:
#   - PSLGang/Data/CVBS_1_Dis_neg_1.mzML
#
# If no valid file is found, it falls back to ../data/sample.mzML

# Temp path to .mzML file (will prefer a file in the Data/ folder if present)
script_dir = os.path.dirname(os.path.abspath(__file__))
repo_root = os.path.abspath(os.path.join(script_dir, ".."))

default_paths = [
    os.path.join(repo_root, "Data", "CVBS_1_Dis_neg_1.mzML"),
    os.path.join(repo_root, "data", "sample.mzML"),
]
if len(sys.argv) > 1:
    mzml_path = sys.argv[1]
else:
    mzml_path = None
    for p in default_paths:
        if os.path.exists(p):
            mzml_path = p
            break
    if mzml_path is None:
        # fallback to repo-root relative path used previously
        mzml_path = os.path.join(repo_root, "data", "sample.mzML")


def parse_mzml(mzml_path):

    """
    Parses an .mzML file and extracts spectra metadata.

    Parameters
    ----------
    mzml_path : str
        Absolute or relative path to the .mzML file.

    Returns
    -------
    list[dict]
        A list of dictionaries containing:
            - id: spectrum identifier
            - ms_level: cvParam dictionary for MS level
            - base_peak_mz: cvParam dictionary for base peak m/z
            - base_peak_intensity: cvParam dictionary for base peak intensity

    Raises
    ------
    FileNotFoundError
        If the input file does not exist.
    """

    # Ensure the file exists before parsing
    if not os.path.exists(mzml_path):
        raise FileNotFoundError(f"mzML file not found: {mzml_path}")
    
    tree = ET.parse(mzml_path)
    root = tree.getroot()

    # Extract default namespace if present
    m = re.match(r"\{(.+)\}", root.tag)
    ns = {"ns": m.group(1)} if m else None

    spectra_data = []

    # Choose the correct find expression depending on whether a namespace was found
    if ns:
        spectrum_iter = root.findall(".//ns:spectrum", ns)
        cvparam_expr = ".//ns:cvParam"
    else:
        spectrum_iter = root.findall(".//spectrum")
        cvparam_expr = ".//cvParam"

    for spectrum in spectrum_iter:
        spec_id = spectrum.get("id")

        # Using a regular expression to extract just the "scan="" part, then fallback to original if no match
        match = re.search(r"(scan=\d+)", spec_id or "")
        spec_id = match.group(1) if match else spec_id

        # Extracting only the value for each measurement to simplify output.
        ms_level = None
        base_peak_mz = None
        base_peak_intensity = None

        for param in spectrum.findall(cvparam_expr, ns if ns else None):
            name = param.get("name")
            value = param.get("value")

            if name == "ms level":
                ms_level = value
            elif name == "base peak m/z":
                base_peak_mz = value
            elif name == "base peak intensity":
                base_peak_intensity = value

        # Only keep spectra where ms level == "1"
        if ms_level == "1":
            # Convert numeric-looking values from scientific notation into plain decimal strings
            def fmt_num_str(s):
                if s is None:
                    return None
                try:
                    # Decimal preserves exact value and we can format without exponent
                    d = Decimal(str(s))
                    # normalize to remove exponent, then quantize to remove trailing exponent
                    # but avoid losing precision by using plain str(d.normalize()) when possible
                    # We'll convert to a plain string with no exponent by using 'f' formatting
                    # with enough precision. Use as_tuple to estimate digits.
                    tup = d.as_tuple()
                    digits = len(tup.digits)
                    # choose a precision large enough to hold all digits
                    plain = format(d, 'f')
                    return plain
                except Exception:
                    return s

            spectra_data.append({
                "id": spec_id,
                "ms_level": ms_level,
                "base_peak_mz": fmt_num_str(base_peak_mz),
                "base_peak_intensity": fmt_num_str(base_peak_intensity),
            })

    return spectra_data

# -------------------------------------------------------------------
# Main Execution
# -------------------------------------------------------------------
# When executed directly (not imported), the script:
#   1. Parses the input mzML file
#   2. Extracts ms-level=1 spectra
#   3. Saves results to a JSON file next to the original data file
# -------------------------------------------------------------------

if __name__ == "__main__":
    try:
        spectra = parse_mzml(mzml_path)

        base_name = os.path.splitext(os.path.basename(mzml_path))[0]
        output_path = os.path.join(os.path.dirname(mzml_path), f"{base_name}.json")

        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(spectra, f, indent=2)

        print(f"Extracted {len(spectra)} ms-level=1 spectra to {output_path}")
    except Exception as e:
        print(f"Error while parsing mzML: {e}")
        raise